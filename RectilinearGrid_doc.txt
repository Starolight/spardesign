    RectilinearGrid - a dataset that is topologically regular with
    variable spacing in the three coordinate directions
    
    Superclass: DataSet
    
    RectilinearGrid is a data object that is a concrete implementation
    of DataSet. RectilinearGrid represents a geometric structure
    that is topologically regular with variable spacing in the three
    coordinate directions x-y-z.
    
    To define a RectilinearGrid, you must specify the dimensions of
    the data and provide three arrays of values specifying the
    coordinates along the x-y-z axes. The coordinate arrays are specified
    using three DataArray objects (one for x, one for y, one for z).
    
    Caveats:
    
    Make sure that the dimensions of the grid match the number of
    coordinates in the x-y-z directions. If not, unpredictable results
    (including program failure) may result. Also, you must supply
    coordinates in all three directions, even if the dataset topology is
    2d, 1d, or 0d.
    
    
Traits:
-------------------


whole_extent: 
        Set/Get the whole extent of this data object. The whole extent is
        meta data for structured data sets. It gets set by the source
        during the update information call.
        
producer_port: 
        Get the port currently producing this object.
        
class_name: 
        Return the class name as a string. This method is defined in all
        subclasses of ObjectBase with the TypeMacro found in
        SetGet.h.
        
z_coordinates: 
        Specify the grid coordinates in the z-direction.
        
m_time: 
        Return this object's modified time.
        
maximum_number_of_pieces: 
        Set/Get the maximum number of pieces that can be requested. The
        maximum number of pieces is meta data for unstructured data sets.
        It gets set by the source during the update information call. A
        value of -1 indicates that there is no maximum.
        
whole_bounding_box: 
        Set/Get the whole bounding box of this data object. The whole
        whole bounding box is meta data for data sets It gets set by the
        source during the update information call.
        
number_of_points: 
        Determine the number of points composing the dataset. THIS METHOD
        IS THREAD SAFE
        
actual_memory_size: 
        Return the actual size of the data in kilobytes. This number is
        valid only after the pipeline has updated. The memory size
        returned is guaranteed to be greater than or equal to the memory
        required to represent the data (e.g., extra space in arrays, etc.
        are not included in the return value).
        
dimensions: 
        Set dimensions of rectilinear grid dataset. This also sets the
        extent.
        
max_cell_size: 
        Convenience method returns largest cell size in dataset. This is
        generally used to allocate memory for supporting data structures.
        THIS METHOD IS THREAD SAFE
        
number_of_cells: 
        Determine the number of cells composing the dataset. THIS METHOD
        IS THREAD SAFE
        
source: 
        Set/Get the source object creating this data object.
        
release_data_flag: 
        Turn on/off flag to control whether this object's data is
        released after being used by a filter.
        
global_release_data_flag: 
        Turn on/off flag to control whether every object releases its
        data after being used by a filter.
        
pipeline_information: 
        Get/Set the pipeline information object that owns this data
        object.
        
cell_data: 
        Return a pointer to this dataset's cell data. THIS METHOD IS
        THREAD SAFE
        
point_data: 
        Return a pointer to this dataset's point data. THIS METHOD IS
        THREAD SAFE
        
extent_translator: 
        An object that will translate pieces into structured extents.
        
request_exact_extent: 
        This request flag indicates whether the requester can handle more
        data than requested.  Right now it is used in ImageData. Image
        filters can return more data than requested.  The the consumer
        cannot handle this (i.e. data_set_to_data_set_fitler) the image will
        crop itself.  This functionality used to be in
        image_to_structured_points.
        
scalar_range: 
        Convenience method to get the range of the scalar data (if there
        is any scalar data). Returns the (min/max) range of combined
        point and cell data. If there are no point or cell scalars the
        method will return (0,1). Note: Update needs to be called to
        create the scalars. THIS METHOD IS THREAD SAFE IF FIRST CALLED
        FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED
        
update_piece: 
        Set / Get the update piece and the update number of pieces.
        Similar to update extent in 3d.
        
update_time: 
        Used by Threaded ports to determine if they should initiate an
        asynchronous update (still in development).
        
data_released: 
        Get the flag indicating the data has been released.
        
update_number_of_pieces: 
        Set / Get the update piece and the update number of pieces.
        Similar to update extent in 3d.
        
update_ghost_level: 
        Set / Get the update ghost level and the update number of ghost
        levels. Similar to update extent in 3d.
        
reference_count: 
        Sets the reference count. (This is very dangerous, use with
        care.)
        
x_coordinates: 
        Specify the grid coordinates in the x-direction.
        
extent: 
        Different ways to set the extent of the data array.  The extent
        should be set before the "Scalars" are set or allocated. The
        Extent is stored  in the order (X, Y, Z).
        
field_data: 
        Assign or retrieve a general field data to this data object.
        
global_warning_display: 
        This is a global flag that controls whether any debug, warning or
        error messages are displayed.
        
center: 
        Get the center of the bounding box. THIS METHOD IS NOT THREAD
        SAFE.
        
extent_type: 
        The extent_type will be left as VTK_PIECES_EXTENT for data objects
        such as PolyData and UnstructuredGrid. The extent_type will
        be changed to vtk__3d__extent for data objects with 3d structure
        such as ImageData (and its subclass StructuredPoints),
        RectilinearGrid, and StructuredGrid. The default is the
        have an extent in pieces, with only one piece (no streaming
        possible).
        
y_coordinates: 
        Specify the grid coordinates in the y-direction.
        
bounds: 
        Return a pointer to the geometry bounding box in the form
        (xmin,xmax, ymin,ymax, zmin,zmax). THIS METHOD IS NOT THREAD
        SAFE.
        
update_extent: 
        A generic way of specifying an update extent.  Subclasses must
        decide what a piece is.  When the number_of_pieces is zero, then no
        data is requested, and the source will not execute.
        
information: 
        Set/Get the information object associated with this data object.
        
length: 
        Return the length of the diagonal of the bounding box. THIS
        METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND
        THE DATASET IS NOT MODIFIED
        
estimated_memory_size: 
        Get the estimated size of this data object itself. Should be
        called after update_information() and propagate_update_extent() have
        both been called. Should be overridden in a subclass - otherwise
        the default is to assume that this data object requires no
        memory. The size is returned in kilobytes.
        
debug: 
        Set the value of the debug flag. A non-zero value turns debugging
        on.
        
data_dimension: 
        Return the dimensionality of the data.
        
data_object_type: 
        Return class name of data type. This is one of
        VTK_STRUCTURED_GRID, VTK_STRUCTURED_POINTS,
        VTK_UNSTRUCTURED_GRID, VTK_POLY_DATA, or VTK_RECTILINEAR_GRID
        (see SetGet.h for definitions). THIS METHOD IS THREAD SAFE
        
pipeline_m_time: 
        Get the cumulative modified time of everything upstream.  Does
        not include the MTime of this object.
        
Methods:
----------------------


CELL_DATA_VECTOR(self)

V.cell__data__vector() -> InformationInformationVectorKey
C++: static InformationInformationVectorKey *CELL_DATA_VECTOR()


DATA_EXTENT(self)

V.data__extent() -> InformationIntegerPointerKey
C++: static InformationIntegerPointerKey *DATA_EXTENT()


DATA_EXTENT_TYPE(self)

V.data__extent__type() -> InformationIntegerKey
C++: static InformationIntegerKey *DATA_EXTENT_TYPE()


DATA_GEOMETRY_UNMODIFIED(self)

V.data__geometry__unmodified() -> InformationIntegerKey
C++: static InformationIntegerKey *DATA_GEOMETRY_UNMODIFIED()


DATA_NUMBER_OF_GHOST_LEVELS(self)

V.data__number__of__ghost__levels() -> InformationIntegerKey
C++: static InformationIntegerKey *DATA_NUMBER_OF_GHOST_LEVELS(
    )


DATA_NUMBER_OF_PIECES(self)

V.data__number__of__pieces() -> InformationIntegerKey
C++: static InformationIntegerKey *DATA_NUMBER_OF_PIECES()


DATA_OBJECT(self)

V.data__object() -> InformationDataObjectKey
C++: static InformationDataObjectKey *DATA_OBJECT()


DATA_PIECE_NUMBER(self)

V.data__piece__number() -> InformationIntegerKey
C++: static InformationIntegerKey *DATA_PIECE_NUMBER()


DATA_RESOLUTION(self)

V.data__resolution() -> InformationDoubleKey
C++: static InformationDoubleKey *DATA_RESOLUTION()


DATA_TIME_STEPS(self)

V.data__time__steps() -> InformationDoubleVectorKey
C++: static InformationDoubleVectorKey *DATA_TIME_STEPS()


DATA_TYPE_NAME(self)

V.data__type__name() -> InformationStringKey
C++: static InformationStringKey *DATA_TYPE_NAME()


EDGE_DATA_VECTOR(self)

V.edge__data__vector() -> InformationInformationVectorKey
C++: static InformationInformationVectorKey *EDGE_DATA_VECTOR()


FIELD_ACTIVE_ATTRIBUTE(self)

V.field__active__attribute() -> InformationIntegerKey
C++: static InformationIntegerKey *FIELD_ACTIVE_ATTRIBUTE()


FIELD_ARRAY_NAME(self)

V.field__array__name() -> InformationStringKey
C++: static InformationStringKey *FIELD_ARRAY_NAME()


FIELD_ARRAY_TYPE(self)

V.field__array__type() -> InformationIntegerKey
C++: static InformationIntegerKey *FIELD_ARRAY_TYPE()


FIELD_ASSOCIATION(self)

V.field__association() -> InformationIntegerKey
C++: static InformationIntegerKey *FIELD_ASSOCIATION()


FIELD_ATTRIBUTE_TYPE(self)

V.field__attribute__type() -> InformationIntegerKey
C++: static InformationIntegerKey *FIELD_ATTRIBUTE_TYPE()


FIELD_NAME(self)

V.field__name() -> InformationStringKey
C++: static InformationStringKey *FIELD_NAME()


FIELD_NUMBER_OF_COMPONENTS(self)

V.field__number__of__components() -> InformationIntegerKey
C++: static InformationIntegerKey *FIELD_NUMBER_OF_COMPONENTS()


FIELD_NUMBER_OF_TUPLES(self)

V.field__number__of__tuples() -> InformationIntegerKey
C++: static InformationIntegerKey *FIELD_NUMBER_OF_TUPLES()


FIELD_OPERATION(self)

V.field__operation() -> InformationIntegerKey
C++: static InformationIntegerKey *FIELD_OPERATION()


FIELD_RANGE(self)

V.field__range() -> InformationDoubleVectorKey
C++: static InformationDoubleVectorKey *FIELD_RANGE()


ORIGIN(self)

V.origin() -> InformationDoubleVectorKey
C++: static InformationDoubleVectorKey *ORIGIN()


PIECE_EXTENT(self)

V.piece__extent() -> InformationIntegerVectorKey
C++: static InformationIntegerVectorKey *PIECE_EXTENT()


PIECE_FIELD_RANGE(self)

V.piece__field__range() -> InformationDoubleVectorKey
C++: static InformationDoubleVectorKey *PIECE_FIELD_RANGE()


POINT_DATA_VECTOR(self)

V.point__data__vector() -> InformationInformationVectorKey
C++: static InformationInformationVectorKey *POINT_DATA_VECTOR(
    )


SIL(self)

V.sil() -> InformationDataObjectKey
C++: static InformationDataObjectKey *SIL()


SPACING(self)

V.spacing() -> InformationDoubleVectorKey
C++: static InformationDoubleVectorKey *SPACING()


VERTEX_DATA_VECTOR(self)

V.vertex__data__vector() -> InformationInformationVectorKey
C++: static InformationInformationVectorKey *VERTEX_DATA_VECTOR(
    )


add_observer(self, *args)

V.add_observer(int, function) -> int
C++: unsigned long AddObserver(const char *event,
    Command *command, float priority=0.0f)
Add an event callback function(vtk_object, int) for an event type.
Returns a handle that can be used with remove_event(int).


break_on_error(self)

V.break_on_error()
C++: static void BreakOnError()
This method is called when ErrorMacro executes. It allows the
debugger to break on error.


check_attributes(self)

V.check_attributes() -> int
C++: int CheckAttributes()
This method checks to see if the cell and point attributes match
the geometry.  Many filters will crash if the number of tupples
in an array is less than the number of points/cells. This method
returns 1 if there is a mismatch, and 0 if everything is ok.  It
prints an error if an array is too short, and a warning if an
array is too long.


compute_bounds(self)

V.compute_bounds()
C++: virtual void ComputeBounds()
Compute the data bounding box from data points. THIS METHOD IS
NOT THREAD SAFE.


compute_cell_id(self, *args)

V.compute_cell_id([int, int, int]) -> int
C++: IdType ComputeCellId(int ijk[3])
Given a location in structured coordinates (i-j-k), return the
cell id.


compute_point_id(self, *args)

V.compute_point_id([int, int, int]) -> int
C++: IdType ComputePointId(int ijk[3])
Given a location in structured coordinates (i-j-k), return the
point id.


compute_structured_coordinates(self, *args)

V.compute_structured_coordinates([float, float, float], [int, int,
    int], [float, float, float]) -> int
C++: int ComputeStructuredCoordinates(double x[3], int ijk[3],
    double pcoords[3])
Convenience function computes the structured coordinates for a
point x[3]. The cell is specified by the array ijk[3], and the
parametric coordinates in the cell are specified with pcoords[3].
The function returns a 0 if the point x is outside of the grid,
and a 1 if inside the grid.


copy_attributes(self, *args)

V.copy_attributes(DataSet)
C++: virtual void CopyAttributes(DataSet *ds)
Copy the attributes associated with the specified dataset to this
instance of DataSet. THIS METHOD IS NOT THREAD SAFE.


copy_information(self, *args)

V.copy_information(DataObject)
C++: void CopyInformation(DataObject *data)
Copy the generic information (_whole_extent ...)


copy_information_from_pipeline(self, *args)

V.copy_information_from_pipeline(Information)
C++: virtual void CopyInformationFromPipeline(
    Information *request)
Copy information about this data object from the
pipeline_information to its own Information for the given request.


copy_information_to_pipeline(self, *args)

V.copy_information_to_pipeline(Information, Information,
    Information, int)
C++: virtual void CopyInformationToPipeline(
    Information *request, Information *input,
    Information *output, int forceCopy)
V.copy_information_to_pipeline(Information, Information)
C++: void CopyInformationToPipeline(Information *request,
    Information *input)
Copy information about this data object to the output information
from its own Information for the given request.  If the second
argument is not NULL then it is the pipeline information object
for the input to this data object's producer. If force_copy is
true, information is copied even if it exists in the output.


copy_structure(self, *args)

V.copy_structure(DataSet)
C++: virtual void CopyStructure(DataSet *ds)
Copy the geometric and topological structure of an object. Note
that the invoking object and the object pointed to by the
parameter ds must be of the same type. THIS METHOD IS NOT THREAD
SAFE.


copy_type_specific_information(self, *args)

V.copy_type_specific_information(DataObject)
C++: virtual void CopyTypeSpecificInformation(DataObject *data)
By default, there is no type specific information


crop(self)

V.crop()
C++: virtual void Crop()
This method crops the data object (if necesary) so that the
extent matches the update extent.


data_has_been_generated(self)

V.data_has_been_generated()
C++: void DataHasBeenGenerated()
This method is called by the source when it executes to generate
data. It is sort of the opposite of release_data. It sets the
data_released flag to 0, and sets a new update_time.


deep_copy(self, *args)

V.deep_copy(DataObject)
C++: virtual void DeepCopy(DataObject *src)
Shallow and Deep copy.  These copy the data, but not any of the
pipeline connections.


fast_delete(self)

V.fast_delete()
C++: virtual void FastDelete()
Delete a reference to this object.  This version will not invoke
garbage collection and can potentially leak the object if it is
part of a reference loop.  Use this method only when it is known
that the object has another reference and would not be collected
if a full garbage collection check were done.


find_point(self, *args)

V.find_point(float, float, float) -> int
C++: IdType FindPoint(double x, double y, double z)
V.find_point([float, float, float]) -> int
C++: virtual IdType FindPoint(double x[3])
Locate the closest point to the global coordinate x. Return the
point id. If point id < 0; then no point found. (This may arise
when point is outside of dataset.) THIS METHOD IS THREAD SAFE IF
FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED


generate_ghost_level_array(self)

V.generate_ghost_level_array()
C++: virtual void GenerateGhostLevelArray()
Normally called by pipeline executives or algoritgms only. This
method computes the ghost arrays for a given dataset.


get(self, *names, **metadata)

Shortcut for getting object trait attributes.

Parameters
----------
names : list of trait attribute names
    Trait attributes whose values are requested

Returns
-------
A dictionary whose keys are the names passed as arguments and whose
values are the corresponding trait values

Description
-----------
Looks up the value of each trait whose name is passed as an argument
and returns a dictionary containing the resulting name/value pairs.
If any name does not correspond to a defined trait, it is not included
in the result.

If no names are specified, the result is a dictionary containing
name/value pairs for *all* traits defined on the object.


get_active_field_information(self, *args)

V.get_active_field_information(Information, int, int)
    -> Information
C++: static Information *GetActiveFieldInformation(
    Information *info, int fieldAssociation, int attributeType)
Return the information object within the input information
object's field data corresponding to the specified association
(FIELD_ASSOCIATION_POINTS or FIELD_ASSOCIATION_CELLS) and
attribute (SCALARS, VECTORS, NORMALS, TCOORDS, or TENSORS)


get_address_as_string(self, *args)

V.get_address_as_string(string) -> string
C++: const char *GetAddressAsString()
Get address of C++ object in format 'Addr=%p' after casting to
the specified type.  You can get the same information from o.__this__.


get_association_type_as_string(self, *args)

V.get_association_type_as_string(int) -> string
C++: static const char *GetAssociationTypeAsString(
    int associationType)
Given an integer association type, this static method returns a
string type for the attribute (i.e. type = 0: returns "Points").


get_attribute_type_for_array(self, *args)

V.get_attribute_type_for_array(AbstractArray) -> int
C++: virtual int GetAttributeTypeForArray(AbstractArray *arr)
Retrieves the attribute type that an array came from. This is
useful for obtaining which attribute type a input array to an
algorithm came from (retrieved from
get_input_abstract_array_to_processs).


get_attributes(self, *args)

V.get_attributes(int) -> DataSetAttributes
C++: virtual DataSetAttributes *GetAttributes(int type)
Returns the attributes of the data object of the specified
attribute type. The type may be:  POINT  - Defined in DataSet
subclasses. CELL   - Defined in DataSet subclasses. VERTEX -
Defined in Graph subclasses. EDGE   - Defined in Graph
subclasses. ROW    - Defined in Table.  The other attribute
type, FIELD, will return NULL since field data is stored as a
FieldData instance, not a DataSetAttributes instance. To
retrieve field data, use get_attributes_as_field_data.


get_attributes_as_field_data(self, *args)

V.get_attributes_as_field_data(int) -> FieldData
C++: virtual FieldData *GetAttributesAsFieldData(int type)
Returns the attributes of the data object as a FieldData. This
returns non-null values in all the same cases as get_attributes,
in addition to the case of FIELD, which will return the field
data for any DataObject subclass.


get_cell(self, *args)

V.get_cell(int) -> Cell
C++: virtual Cell *GetCell(IdType cellId)
V.get_cell(int, GenericCell)
C++: virtual void GetCell(IdType cellId, GenericCell *cell)
Get cell with cell_id such that: 0 <= cell_id < number_of_cells. THIS
METHOD IS NOT THREAD SAFE.


get_cell_bounds(self, *args)

V.get_cell_bounds(int, [float, float, float, float, float, float])
C++: virtual void GetCellBounds(IdType cellId,
    double bounds[6])
Get the bounds of the cell with cell_id such that:
    0 <= cell_id < number_of_cells. A subclass may be able to
determine the bounds of cell without using an expensive get_cell()
method. A default implementation is provided that actually uses a
get_cell() call.  This is to ensure the method is available to all
datasets.  Subclasses should override this method to provide an
efficient implementation. THIS METHOD IS THREAD SAFE IF FIRST
CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED


get_cell_neighbors(self, *args)

V.get_cell_neighbors(int, IdList, IdList)
C++: virtual void GetCellNeighbors(IdType cellId,
    IdList *ptIds, IdList *cellIds)
Topological inquiry to get all cells using list of points
exclusive of cell specified (e.g., cell_id). Note that the list
consists of only cells that use ALL the points provided. THIS
METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND
THE DATASET IS NOT MODIFIED


get_cell_points(self, *args)

V.get_cell_points(int, IdList)
C++: virtual void GetCellPoints(IdType cellId,
    IdList *ptIds)
Topological inquiry to get points defining cell. THIS METHOD IS
THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET
IS NOT MODIFIED


get_cell_type(self, *args)

V.get_cell_type(int) -> int
C++: virtual int GetCellType(IdType cellId)
Get type of cell with cell_id such that: 0 <= cell_id <
number_of_cells. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A
SINGLE THREAD AND THE DATASET IS NOT MODIFIED


get_cell_types(self, *args)

V.get_cell_types(CellTypes)
C++: virtual void GetCellTypes(CellTypes *types)
Get a list of types of cells in a dataset. The list consists of
an array of types (not necessarily in any order), with a single
entry per type. For example a dataset 5 triangles, 3 lines, and
100 hexahedra would result a list of three entries, corresponding
to the types VTK_TRIANGLE, VTK_LINE, and VTK_HEXAHEDRON. THIS
METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND
THE DATASET IS NOT MODIFIED


get_data(self, *args)

V.get_data(Information) -> DataObject
C++: static DataObject *GetData(Information *info)
V.get_data(InformationVector, int) -> DataObject
C++: static DataObject *GetData(InformationVector *v,
    int i=0)
Retrieve an instance of this class from an information object.


get_named_field_information(self, *args)

V.get_named_field_information(Information, int, string)
    -> Information
C++: static Information *GetNamedFieldInformation(
    Information *info, int fieldAssociation, const char *name)
Return the information object within the input information
object's field data corresponding to the specified association
(FIELD_ASSOCIATION_POINTS or FIELD_ASSOCIATION_CELLS) and name.


get_number_of_elements(self, *args)

V.get_number_of_elements(int) -> int
C++: virtual IdType GetNumberOfElements(int type)
Get the number of elements for a specific attribute type (POINT,
CELL, etc.).


get_point(self, *args)

V.get_point(int) -> (float, float, float)
C++: virtual double *GetPoint(IdType ptId)
V.get_point(int, [float, float, float])
C++: virtual void GetPoint(IdType id, double x[3])
Get point coordinates with pt_id such that: 0 <= pt_id <
number_of_points. THIS METHOD IS NOT THREAD SAFE.


get_point_cells(self, *args)

V.get_point_cells(int, IdList)
C++: virtual void GetPointCells(IdType ptId,
    IdList *cellIds)
Topological inquiry to get cells using point. THIS METHOD IS
THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET
IS NOT MODIFIED


has_observer(self, *args)

V.has_observer(int) -> int
C++: int HasObserver(unsigned long event)
V.has_observer(string) -> int
C++: int HasObserver(const char *event)
Allow people to add/remove/invoke observers (callbacks) to any
VTK object.  This is an implementation of the subject/observer
design pattern. An observer is added by specifying an event to
respond to and a Command to execute. It returns an unsigned
long tag which can be used later to remove the event or retrieve
the command. When events are invoked, the observers are called in
the order they were added. If a priority value is specified, then
the higher priority commands are called first. A command may set
an abort flag to stop processing of the event. (See Command.h
for more information.)


initialize(self)

V.initialize()
C++: virtual void Initialize()
Restore data object to initial state,


invoke_event(self, *args)

V.invoke_event(int, ) -> int
C++: int InvokeEvent(unsigned long event, void *callData)
V.invoke_event(string, ) -> int
C++: int InvokeEvent(const char *event, void *callData)
V.invoke_event(int) -> int
C++: int InvokeEvent(unsigned long event)
V.invoke_event(string) -> int
C++: int InvokeEvent(const char *event)
This method invokes an event and return whether the event was
aborted or not. If the event was aborted, the return value is 1,
otherwise it is 0.


is_a(self, *args)

V.is_a(string) -> int
C++: virtual int IsA(const char *name)
Return 1 if this class is the same type of (or a subclass of) the
named class. Returns 0 otherwise. This method works in
combination with TypeMacro found in SetGet.h.


is_type_of(self, *args)

V.is_type_of(string) -> int
C++: static int IsTypeOf(const char *name)
Return 1 if this class type is the same type of (or a subclass
of) the named class. Returns 0 otherwise. This method works in
combination with TypeMacro found in SetGet.h.


modified(self)

V.modified()
C++: virtual void Modified()
Update the modification time for this object. Many filters rely
on the modification time to determine if they need to recompute
their data. The modification time is a unique monotonically
increasing unsigned long integer.


new_instance(self)

V.new_instance() -> Object
C++: Object *NewInstance()


prepare_for_new_data(self)

V.prepare_for_new_data()
C++: virtual void PrepareForNewData()
make the output data ready for new data to be inserted. For most
objects we just call Initialize. But for ImageData we leave
the old data in case the memory can be reused.


print_revisions(self)

V.print_revisions() -> string
C++: const char *PrintRevisions()
Prints the .cxx file CVS revisions of the classes in the
object's inheritance chain.


propagate_update_extent(self)

V.propagate_update_extent()
C++: virtual void PropagateUpdateExtent()
WARNING: INTERNAL METHOD - NOT FOR GENERAL USE. THIS METHOD IS
PART OF THE PIPELINE UPDATE FUNCTIONALITY. The update extent for
this object is propagated up the pipeline. This propagation may
early terminate based on the pipeline_m_time.


register(self, *args)

V.register(ObjectBase)
C++: virtual void Register(ObjectBase *o)
Increase the reference count by 1.


release_data(self)

V.release_data()
C++: void ReleaseData()
Release data back to system to conserve memory resource. Used
during visualization network execution.  Releasing this data does
not make down-stream data invalid, so it does not modify the
MTime of this data object.


remove_all_observers(self)

V.remove_all_observers()
C++: void RemoveAllObservers()
Allow people to add/remove/invoke observers (callbacks) to any
VTK object.  This is an implementation of the subject/observer
design pattern. An observer is added by specifying an event to
respond to and a Command to execute. It returns an unsigned
long tag which can be used later to remove the event or retrieve
the command. When events are invoked, the observers are called in
the order they were added. If a priority value is specified, then
the higher priority commands are called first. A command may set
an abort flag to stop processing of the event. (See Command.h
for more information.)


remove_named_field_information(self, *args)

V.remove_named_field_information(Information, int, string)
C++: static void RemoveNamedFieldInformation(Information *info,
     int fieldAssociation, const char *name)
Remove the info associated with an array


remove_observer(self, *args)

V.remove_observer(int)
C++: void RemoveObserver(unsigned long tag)
Allow people to add/remove/invoke observers (callbacks) to any
VTK object.  This is an implementation of the subject/observer
design pattern. An observer is added by specifying an event to
respond to and a Command to execute. It returns an unsigned
long tag which can be used later to remove the event or retrieve
the command. When events are invoked, the observers are called in
the order they were added. If a priority value is specified, then
the higher priority commands are called first. A command may set
an abort flag to stop processing of the event. (See Command.h
for more information.)


remove_observers(self, *args)

V.remove_observers(int)
C++: void RemoveObservers(unsigned long event)
V.remove_observers(string)
C++: void RemoveObservers(const char *event)
Allow people to add/remove/invoke observers (callbacks) to any
VTK object.  This is an implementation of the subject/observer
design pattern. An observer is added by specifying an event to
respond to and a Command to execute. It returns an unsigned
long tag which can be used later to remove the event or retrieve
the command. When events are invoked, the observers are called in
the order they were added. If a priority value is specified, then
the higher priority commands are called first. A command may set
an abort flag to stop processing of the event. (See Command.h
for more information.)


safe_down_cast(self, *args)

V.safe_down_cast(Object) -> Object
C++: Object *SafeDownCast(Object* o)


set(self, trait_change_notify=True, **traits)

Shortcut for setting object trait attributes.

Parameters
----------
trait_change_notify : Boolean
    If **True** (the default), then each value assigned may generate a
    trait change notification. If **False**, then no trait change
    notifications will be generated. (see also: trait_setq)
traits : list of key/value pairs
    Trait attributes and their values to be set

Returns
-------
self
    The method returns this object, after setting attributes.

Description
-----------
Treats each keyword argument to the method as the name of a trait
attribute and sets the corresponding trait attribute to the value
specified. This is a useful shorthand when a number of trait attributes
need to be set on an object, or a trait attribute value needs to be set
in a lambda function. For example, you can write::

    person.trait_set(name='Bill', age=27)

instead of::

    person.name = 'Bill'
    person.age = 27


set_active_attribute(self, *args)

V.set_active_attribute(Information, int, string, int)
    -> Information
C++: static Information *SetActiveAttribute(
    Information *info, int fieldAssociation,
    const char *attributeName, int attributeType)
Set the named array to be the active field for the specified type
(SCALARS, VECTORS, NORMALS, TCOORDS, or TENSORS) and association
(FIELD_ASSOCIATION_POINTS or FIELD_ASSOCIATION_CELLS).  Returns
the active field information object and creates on entry if one
not found.


set_active_attribute_info(self, *args)

V.set_active_attribute_info(Information, int, int, string, int,
    int, int)
C++: static void SetActiveAttributeInfo(Information *info,
    int fieldAssociation, int attributeType, const char *name,
    int arrayType, int numComponents, int numTuples)
Set the name, array type, number of components, and number of
tuples within the passed information object for the active
attribute of type attribute_type (in specified association,
FIELD_ASSOCIATION_POINTS or FIELD_ASSOCIATION_CELLS).  If there
is not an active attribute of the specified type, an entry in the
information object is created.  If array_type, num_components, or
num_tuples equal to -1, or name=NULL the value is not changed.


set_point_data_active_scalar_info(self, *args)

V.set_point_data_active_scalar_info(Information, int, int)
C++: static void SetPointDataActiveScalarInfo(
    Information *info, int arrayType, int numComponents)
Convenience version of previous method for use (primarily) by the
Imaging filters. If array_type or num_components == -1, the value
is not changed.


set_update_extent_to_whole_extent(self)

V.set_update_extent_to_whole_extent()
C++: void SetUpdateExtentToWholeExtent()
If the whole input extent is required to generate the requested
output extent, this method can be called to set the input update
extent to the whole input extent. This method assumes that the
whole extent is known (that update_information has been called)


setup_observers(self)

Add an observer for the ModifiedEvent so the traits are kept
up-to-date with the wrapped VTK object and do it in a way that
avoids reference cycles.


shallow_copy(self, *args)

V.shallow_copy(DataObject)
C++: virtual void ShallowCopy(DataObject *src)
Shallow and Deep copy.  These copy the data, but not any of the
pipeline connections.


should_i_release_data(self)

V.should_i_release_data() -> int
C++: int ShouldIReleaseData()
Return flag indicating whether data should be released after use
by a filter.


squeeze(self)

V.squeeze()
C++: virtual void Squeeze()
Reclaim any extra memory used to store data. THIS METHOD IS NOT
THREAD SAFE.


teardown_observers(self)

Remove the observer for the Modified event.


trigger_asynchronous_update(self)

V.trigger_asynchronous_update()
C++: virtual void TriggerAsynchronousUpdate()
WARNING: INTERNAL METHOD - NOT FOR GENERAL USE. THIS METHOD IS
PART OF THE PIPELINE UPDATE FUNCTIONALITY. Propagate back up the
pipeline for ports and trigger the update on the other side of
the port to allow for asynchronous parallel processing in the
pipeline. This propagation may early terminate based on the
pipeline_m_time.


un_register(self, *args)

V.un_register(ObjectBase)
C++: virtual void UnRegister(ObjectBase *o)
Decrease the reference count (release by another object). This
has the same effect as invoking Delete() (i.e., it reduces the
reference count by 1).


update(self)

V.update()
C++: virtual void Update()
Provides opportunity for the data object to insure internal
consistency before access. Also causes owning source/filter (if
any) to update itself. The Update() method is composed of
update_information(), propagate_update_extent(),
trigger_asynchronous_update(), and update_data().


update_data(self)

V.update_data()
C++: virtual void UpdateData()
WARNING: INTERNAL METHOD - NOT FOR GENERAL USE. THIS METHOD IS
PART OF THE PIPELINE UPDATE FUNCTIONALITY. Propagate the update
back up the pipeline, and perform the actual work of updating on
the way down. When the propagate arrives at a port, block and
wait for the asynchronous update to finish on the other side.
This propagation may early terminate based on the pipeline_m_time.


update_information(self)

V.update_information()
C++: virtual void UpdateInformation()
WARNING: INTERNAL METHOD - NOT FOR GENERAL USE. THIS METHOD IS
PART OF THE PIPELINE UPDATE FUNCTIONALITY. Update all the "easy to
update" information about the object such as the extent which
will be used to control the update. This propagates all the way
up then back down the pipeline. As a by-product the pipeline_m_time
is updated.


update_traits(self, obj=None, event=None)

Updates all the 'updateable' traits of the object.

The method works by getting the current value from the wrapped
VTK object.  `self._updateable_traits_` stores a tuple of
tuples containing the trait name followed by the name of the
get method to use on the wrapped VTK object.

The `obj` and `event` parameters may be ignored and are not
used in the function.  They exist only for compatibility with
the VTK observer callback functions.

