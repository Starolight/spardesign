import numpy as np
import VABSobjects as vo
import matplotlib.pyplot as plt


### [description]
###		input: number_of_rows
###		       number_of_columns
###		       number_of_elements
###		       number_of_nodes
###		       element
###		       unique_node
###		output: element
def genElementMap(number_of_rows,number_of_columns,number_of_elements,number_of_nodes,element,unique_node):
	# nodeList = list of node numbers
	# reshapedList = reshaped list of node numbers that has the same shape as the 2D grid
	# elementMap = 2D array of node numbers, arranged in the order of the 2D grid generated by the cartGrid methods

	# for example:
	# if number_of_nodes = 10, number_of_rows = 1, number_of_columns = 4
	#
	# nodeList     = [ 1  2  3  4  5  6  7  8  9 10]
	#
	# reshapedList = [[ 1  3  5  7  9]
 	#                 [ 2  4  6  8 10]]
 	#
	# elementMap = [[ 2  4  6  8 10]
 	#               [ 1  3  5  7  9]]

	nodeList = np.array( range(1, number_of_nodes+1) )
	reshapedList = np.reshape(nodeList, (number_of_rows+1, number_of_columns+1), order='F')
	elementMap = reshapedList[ ::-1,:]  # equivalent to MATLAB's "flipud" function

	# print "node list:"
	# print nodeList, "\n"
	# print "element map:"
	# print elementMap, "\n"

	n = 1  # initialize counter for element number
	for row in range(number_of_rows):
		for col in range(number_of_columns):
			element[n].elem_no = n
			(node1_no, node2_no, node3_no, node4_no) = (elementMap[row+1,col], elementMap[row+1,col+1], elementMap[row,col+1], elementMap[row,col])
			(element[n].node1, element[n].node2, element[n].node3, element[n].node4) = (unique_node[node1_no], unique_node[node2_no], unique_node[node3_no], unique_node[node4_no])
			n = n+1
	return (element,elementMap)


def extractEdges(elementMap):
	left   = elementMap[:,0]
	right  = elementMap[:,-1]
	top    = elementMap[0,:]
	bottom = elementMap[-1,:]
	return (left,right,top,bottom)


def plotGridLines(elementMap,unique_node):
	(left,right,top,bottom) = extractEdges(elementMap)

	## vertical lines ##
	for i in range(len(top)):
		# x = np.array([unique_node[top[i]].x2, unique_node[bottom[i]].x2])
		# y = np.array([unique_node[top[i]].x3, unique_node[bottom[i]].x3])
		# plt.plot(x,y,'k-')
		plt.plot(np.array([unique_node[top[i]].x2, unique_node[bottom[i]].x2]), np.array([unique_node[top[i]].x3, unique_node[bottom[i]].x3]), 'k-')

		if i % 100 == 0:  # print progress to screen
			print '          drawing VERTICAL line #' + str(i) + '/' + str(len(top))

	## horizontal lines ##
	for i in range(len(left)):
		# x = np.array([unique_node[left[i]].x2, unique_node[right[i]].x2])
		# y = np.array([unique_node[left[i]].x3, unique_node[right[i]].x3])
		# plt.plot(x,y,'k-')
		plt.plot(np.array([unique_node[left[i]].x2, unique_node[right[i]].x2]), np.array([unique_node[left[i]].x3, unique_node[right[i]].x3]), 'k-')

		if i % 100 == 0:  # print progress to screen
			print '          drawing HORIZONTAL line #' + str(i) + '/' + str(len(left))
	
	return



if __name__ == '__main__':   # if run, not imported
	## initialize number of rows and columns ##
	nrows = 10  # number of element rows
	ncols = 5  # number of element columns

	## calculate the number of elements and nodes for this region ##
	num_elements = nrows * ncols
	num_nodes = (nrows+1) * (ncols+1)

	## initialize objects for the VABSobjects module ##
	unique_node = []  # create an empty list of node objects
	element = []      # create an empty list of element objects

	## call functions from the VABSobjects module ##
	vo.fillNodeObjects(num_nodes, unique_node)
	vo.fillElementObjects(num_elements, element)

	## fill list of node objects ##
	for i in range(1,num_nodes+1):
		unique_node[i].node_no = i
		(unique_node[i].x2, unique_node[i].x3) = (0.0, 0.0)
	# (unique_node[1].x2, unique_node[1].x3) = (0.0, 0.0)
	# (unique_node[2].x2, unique_node[2].x3) = (0.0, 1.0)
	# (unique_node[3].x2, unique_node[3].x3) = (1.0, 0.0)
	# (unique_node[4].x2, unique_node[4].x3) = (1.0, 1.0)

	## generate the element map, and store it in the list of element objects ##
	(element,eMap) = genElementMap(nrows,ncols,num_elements,num_nodes,element,unique_node)

	## check if the function correctly assigned the element connectivity ##
	for i in range(1,num_elements+1):
		print element[i].node1.node_no, element[i].node2.node_no, element[i].node3.node_no, element[i].node4.node_no
	
	# print element[1].node1.x2, element[1].node1.x3

	(left,right,top,bottom) = extractEdges(eMap)
	print left, right, top, bottom

	extractGridLines(left,right,top,bottom,unique_node)